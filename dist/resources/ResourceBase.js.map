{"version":3,"sources":["../../src/resources/ResourceBase.js"],"names":["ResourceBase","hasInitialized","config","cache","activeRequests","query","req","res","get","then","entries","requestId","getRequestId","activeRequestPromise","wasFoundInCache","Promise","resolve","enable","readFromCache","data","init","queryService","writeToCache","all","map","transformEntry","entry","notImplemented","store","getCacheStore","$$parent$$","$$store$$","ConfigModel","Object","seal","TypeError","extend","err","transform","error","response","model","Model","Error","cacheBySecondaryKeys","secondaryKeys","length","primaryKeyValue","cacheByPrimaryKey","primaryKey","Array","isArray","writeEntriesToStore","buildCache","keyCache","valueCache","queryKeys","key","value","i","keys","sort","buildFreshStore","toString","$$value$$","altStore","j","push","defineProperty","type","json","JSON","stringify"],"mappings":"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","file":"ResourceBase.js","sourcesContent":["import KeyCache    from '../models/KeyCache';\nimport ValueCache  from '../models/ValueCache';\nimport ConfigRoot  from '../config/ConfigRoot';\nimport Util        from '../Util.js';\n\nclass ResourceBase {\n    constructor() {\n        this.hasInitialized = false;\n        this.config         = null;\n        this.cache          = new KeyCache();\n        this.activeRequests = {};\n    }\n\n    /**\n     * A short hand for `.get()[0]`, returning only the first entry.\n     *\n     * @public\n     * @param   {object}    query\n     * @param   {object}    [req=null]\n     *     An optional object representing the request (i.e. http.IncomingMessage)\n     * @param   {object}    [res=null]\n     *     An optional object representing the response (i.e. http.ServerResponse)\n     * @return  {Promise.<object>}\n     */\n\n    getOne(query, req=null, res=null) {\n        return this.get(query, req, res)\n            .then(entries => {\n                return entries[0] || null;\n            });\n    }\n\n    /**\n     * Queries and returns one or more entries, either from the cache,\n     * or from the integrated service (i.e. XHR, mongo, fs), writing\n     * back into the cache when done.\n     *\n     * @public\n     * @param   {object}    query\n     * @param   {object}    [req=null]\n     *     An optional object representing the request (i.e. http.IncomingMessage)\n     * @param   {object}    [res=null]\n     *     An optional object representing the response (i.e. http.ServerResponse)\n     * @return  {Promise.<object[]>}\n     */\n\n    get(query={}, req=null, res=null) {\n        const requestId = ResourceBase.getRequestId('get', query);\n\n        let activeRequestPromise = null;\n        let wasFoundInCache      = false;\n\n        if (typeof (activeRequestPromise = this.activeRequests[requestId]) !== 'undefined') {\n            // If another identical request is already in progress, return a\n            // reference to that request's promise\n\n            return activeRequestPromise;\n        }\n\n        return (this.activeRequests[requestId] = (\n            Promise.resolve()\n                .then(() => {\n                    let entries = null;\n\n                    if (this.config.cache.enable) {\n                        entries = this.readFromCache(query);\n                    }\n\n                    if (entries) {\n                        // ^ Allows 0 results to be cached\n\n                        wasFoundInCache = true;\n\n                        return entries;\n                    }\n\n                    if (this.config.data.init && !this.hasInitialized) {\n                        return this.config.data.init;\n                    }\n\n                    return this.queryService(query, req, res);\n                })\n                .then(entries => {\n                    this.hasInitialized = true;\n\n                    if (this.config.cache.enable && !wasFoundInCache) {\n                        this.writeToCache(query, entries);\n\n                        entries = this.readFromCache(query);\n                    }\n\n                    return Promise.all(entries.map(entry => this.transformEntry(entry, req, res)));\n                })\n                .then(entries => {\n                    delete this.activeRequests[requestId];\n\n                    return entries;\n                })\n            )\n        );\n    }\n\n    /**\n     * @private\n     * @return {Promise}\n     */\n\n    queryService() {\n        return ResourceBase.notImplemented();\n    }\n\n    /**\n     * @public\n     * @return {Promise}\n     */\n\n    create() {\n        return ResourceBase.notImplemented();\n    }\n\n    /**\n     * @public\n     * @return {Promise}\n     */\n\n    update() {\n        return ResourceBase.notImplemented();\n    }\n\n    /**\n     * @public\n     * @return {Promise}\n     */\n\n    delete() {\n        return ResourceBase.notImplemented();\n    }\n\n    /**\n     * Queries and flushes an individual store by nullifying the reference.\n     *\n     * @public\n     * @param   {object}\n     * @return  {void}\n     */\n\n    flushCacheStore(query) {\n        const store = this.getCacheStore(query);\n\n        if (!store) return;\n\n        // TODO: ensure secondary key references are also deleted\n\n        store.$$parent$$.$$store$$ = null;\n    }\n\n    /**\n     * Flushes the entire cache for the resource.\n     *\n     * @public\n     * @return  {void}\n     */\n\n    flushCache() {\n        this.cache = new KeyCache();\n    }\n\n    /**\n     * Configures the resource with a provided user defined\n     * configuration object.\n     *\n     * @private\n     * @param   {object}   config\n     * @param   {function} ConfigModel\n     * @return  {void}\n     */\n\n    configure(config, ConfigModel=ConfigRoot) {\n        this.config = new ConfigModel();\n\n        Object.seal(this.config);\n\n        if (!(this.config instanceof ConfigRoot)) {\n            throw new TypeError('[resource-base] Resource config must be an ancestor of `ConfigBase`');\n        }\n\n        Util.extend(this.config, config, true);\n    }\n\n    /**\n     * @param   {*} err\n     * @return  {*}\n     */\n\n    transformError(err) {\n        let transform = null;\n\n        if (typeof (transform = this.config.transform.error) === 'function') {\n            throw transform(err);\n        }\n\n        throw err;\n    }\n\n    /**\n     * Passes a returned response through an optional \"transform\" function,\n     * returning the transformed output before it is written to cache.\n     *\n     * @private\n     * @param   {object[]} response\n     * @return  {object[]}\n     */\n\n    transformResponse(response) {\n        let transform = null;\n\n        if (typeof (transform = this.config.transform.response) === 'function') {\n            return transform(response);\n        }\n\n        return response;\n    }\n\n    /**\n     * Maps the entry into an optional model after it is retreived from the\n     * cache, then calls an optional `transformEntry` function.\n     *\n     * @private\n     * @param   {object}           entry\n     * @param   {(object|null)}    req\n     * @return  {Promise.<object>}\n     */\n\n    transformEntry(entry, req) {\n        let model = null;\n\n        return Promise.resolve()\n            .then(() => {\n                let Model = null;\n\n                if (typeof (Model = this.config.data.Model) !== 'function') {\n                    model = entry;\n\n                    return;\n                }\n\n                model = new Model();\n\n                Util.extend(model, entry, true);\n\n                if (typeof model.init === 'function') {\n                    return model.init();\n                }\n            })\n            .then(() => {\n                let transform = null;\n\n                if (typeof (transform = this.config.transform.entry) === 'function') {\n                    return transform(model, req);\n                }\n\n                return model;\n            })\n            .then(model => {\n                if (typeof model === 'undefined') {\n                    throw new Error('[ResourceBase] The provided `transformEntry()` function returned `undefined`');\n                }\n\n                return model;\n            });\n    }\n\n    /**\n     * Queries and returns a reference to an individual store.\n     *\n     * @private\n     * @param   {object} query\n     * @return  {(object[]|null)}\n     */\n\n    readFromCache(query) {\n        const store = this.getCacheStore(query);\n\n        return store;\n    }\n\n    /**\n     * Queries a store and writes one or more entries to it.\n     *\n     * @private\n     * @param   {object}      query\n     * @param   {object[]}    entries\n     * @return  {void}\n     */\n\n    writeToCache(query, entries) {\n        const store                 = this.getCacheStore(query, true);\n        const cacheBySecondaryKeys  = this.config.cache.secondaryKeys.length > 0;\n\n        let primaryKeyValue = null;\n        let cacheByPrimaryKey = false;\n\n        if ((primaryKeyValue = query[this.config.cache.primaryKey]) && Array.isArray(primaryKeyValue)) {\n            cacheByPrimaryKey = true;\n        }\n\n        this.writeEntriesToStore(store, entries, cacheByPrimaryKey, cacheBySecondaryKeys);\n    }\n\n    /**\n     * A generic method for retrieving a cache store via query,\n     * optionally building the store if absent.\n     *\n     * @private\n     * @param   {object}    query\n     * @param   {boolean}   buildCache\n     * @return  {object[]|null}\n     */\n\n    getCacheStore(query, buildCache=false) {\n        let keyCache    = this.cache;\n        let valueCache  = null;\n        let queryKeys   = null;\n        let key         = '';\n        let value       = '';\n        let i           = -1;\n\n        query = query || {};\n\n        // Sort keys to make sure identical queries share the same cache store\n\n        queryKeys = Object.keys(query).sort();\n\n        keyCache = this.cache;\n\n        if (queryKeys.length < 1) {\n            if (!keyCache.$$store$$ && buildCache) {\n                keyCache.$$store$$ = ResourceBase.buildFreshStore(keyCache);\n            }\n\n            return keyCache.$$store$$;\n        }\n\n        for (i = 0; i < queryKeys.length; i++) {\n            key = queryKeys[i];\n\n            if (Array.isArray(query[key])) {\n                // Coerce array queries to strings, but mark as array\n                // with quasi-array notation\n\n                value = '(' + query[key].toString() + ')[]';\n            } else {\n                value = query[key];\n            }\n\n            valueCache = keyCache[key];\n\n            if (!valueCache && buildCache) {\n                valueCache = (keyCache[key] = new ValueCache());\n            } else if (!valueCache) {\n                return null;\n            }\n\n            keyCache = valueCache[value];\n\n            if (!keyCache && buildCache) {\n                keyCache = (valueCache[value] = new KeyCache());\n\n                keyCache.$$parent$$ = valueCache;\n                keyCache.$$value$$ = value;\n            } else if (!keyCache) {\n                return null;\n            }\n\n            if (i === queryKeys.length - 1) {\n                if (!keyCache.$$store$$ && buildCache) {\n                    keyCache.$$store$$ = ResourceBase.buildFreshStore(keyCache);\n                }\n\n                return keyCache.$$store$$;\n            }\n        }\n    }\n\n    /**\n     * Writes one or more entries to a store, optionally caching\n     * them by their secondary keys if defined.\n     *\n     * @private\n     * @param   {object[]}    store\n     * @param   {object[]}    entries\n     * @param   {boolean}     cacheByPrimaryKey\n     *     This must be set explicitly to prevent infinite recursion\n     * @param   {boolean}     cacheBySecondaryKeys\n     *     This must be set explicitly to prevent infinite recursion\n     * @return  {void}\n     */\n\n    writeEntriesToStore(store, entries, cacheByPrimaryKey=false, cacheBySecondaryKeys=false) {\n        let entry    = null;\n        let altStore = null;\n        let query    = null;\n        let key      = '';\n        let i        = -1;\n        let j        = -1;\n\n        if (store.length > 0) throw new Error('[resource-base] Store not empty');\n\n        for (i = 0; (entry = entries[i]); i++) {\n            store.push(entry);\n\n            if (cacheByPrimaryKey) {\n                let query = {};\n\n                query[this.config.cache.primaryKey] = entry[this.config.cache.primaryKey];\n\n                this.writeToCache(query, [entry]);\n            }\n\n            if (!cacheBySecondaryKeys) continue;\n\n            for (j = 0; j < this.config.cache.secondaryKeys.length; j++) {\n                key = this.config.cache.secondaryKeys[j];\n\n                if (typeof entry[key] === 'string') {\n                    query = {};\n                    query[key] = entry[key];\n\n                    altStore = this.getCacheStore(query);\n\n                    if (altStore.length < 1) {\n                        this.writeEntriesToStore(altStore, [entry]);\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * Instantiates a decorated array to act as the store, adding a circular\n     * reference to the parent cache for nullification.\n     *\n     * @private\n     * @static\n     * @param   {KeyCache} keyCache\n     * @return  {object[]}\n     */\n\n    static buildFreshStore(keyCache) {\n        const store = [];\n\n        Object.defineProperty(store, '$$parent$$', {\n            get() {\n                return keyCache;\n            }\n        });\n\n        return store;\n    }\n\n    /**\n     * @param   {('get'|'update'|'create'|'delete')}  type\n     * @param   {object}                              data\n     * @return  {string}\n     */\n\n    static getRequestId(type, data) {\n        const json = JSON.stringify(data);\n\n        return type + '_' + json;\n    }\n\n    /**\n     * @static\n     * @return {Promise}\n     */\n\n    static notImplemented() {\n        return Promise.resolve().then(() => {\n            throw new Error('NOT_IMPLEMENTED');\n        });\n    }\n}\n\nexport default ResourceBase;"]}