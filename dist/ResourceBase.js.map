{"version":3,"sources":["../src/ResourceBase.js"],"names":["ResourceBase","config","cache","activeRequests","query","req","get","then","entries","requestId","getRequestId","activeRequestPromise","wasFoundInCache","Promise","resolve","enableCache","readFromCache","queryService","writeToCache","all","map","transformEntry","entry","console","log","store","getCacheStore","$$parent$$","$$store$$","ConfigModel","TypeError","extend","err","transformError","response","transformResponse","model","Model","init","Error","cacheBySecondaryKeys","secondaryKeys","length","primaryKeyValue","cacheByPrimaryKey","primaryKey","Array","isArray","writeEntriesToStore","buildCache","keyCache","valueCache","queryKeys","key","value","i","Object","keys","buildFreshStore","toString","$$value$$","altStore","j","push","defineProperty","type","data","json","JSON","stringify"],"mappings":"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","file":"ResourceBase.js","sourcesContent":["import KeyCache    from './KeyCache';\nimport ValueCache  from './ValueCache';\nimport ConfigBase  from './ConfigBase';\nimport Util        from './Util.js';\n\nclass ResourceBase {\n    constructor() {\n        this.config         = null;\n        this.cache          = new KeyCache();\n        this.activeRequests = {};\n    }\n\n    /**\n     * A short hand for `.get()[0]`, returning only the first entry.\n     *\n     * @public\n     * @param   {object}    query\n     * @param   {object}    [req=null]\n     *     An optional object representing the request (i.e. ExpressRequest)\n     * @return  {Promise.<object>}\n     */\n\n    getOne(query, req=null) {\n        return this.get(query, req)\n            .then(entries => {\n                return entries[0] || null;\n            });\n    }\n\n    /**\n     * Queries and returns one or more entries, either from the cache,\n     * or from the integrated service (i.e. XHR, mongo, fs), writing\n     * back into the cache when done.\n     *\n     * @public\n     * @param   {object}    query\n     * @param   {object}    [req=null]\n     *     An optional object containing data about the request\n     *     (i.e. ExpressRequest)\n     * @return  {Promise.<object[]>}\n     */\n\n    get(query={}, req=null) {\n        const requestId = ResourceBase.getRequestId('get', query);\n\n        let activeRequestPromise = null;\n        let wasFoundInCache      = false;\n\n        if (typeof (activeRequestPromise = this.activeRequests[requestId]) !== 'undefined') {\n            // If another identical request is already in progress, return a\n            // reference to that request's promise\n\n            return activeRequestPromise;\n        }\n\n        return (this.activeRequests[requestId] = (\n            Promise.resolve()\n                .then(() => {\n                    let entries = null;\n\n                    if (this.config.enableCache) {\n                        entries = this.readFromCache(query);\n                    }\n\n                    if (entries) {\n                        // ^ Allows 0 results to be cached\n\n                        wasFoundInCache = true;\n\n                        return entries;\n                    }\n\n                    return this.queryService(query);\n                })\n                .then(entries => {\n                    if (this.config.enableCache && !wasFoundInCache) {\n                        this.writeToCache(query, entries);\n\n                        entries = this.readFromCache(query);\n                    }\n\n                    return Promise.all(entries.map(entry => this.transformEntry(entry, req)));\n                })\n                .then(entries => {\n                    delete this.activeRequests[requestId];\n\n                    return entries;\n                })\n            )\n        );\n    }\n\n    /**\n     * @public\n     * @return {void}\n     */\n\n    create() {\n        console.log('not implemented');\n    }\n\n    /**\n     * @public\n     * @return {void}\n     */\n\n    update() {\n        console.log('not implemented');\n    }\n\n    /**\n     * @public\n     * @return {void}\n     */\n\n    delete() {\n        console.log('not implemented');\n    }\n\n    /**\n     * Queries and flushes an individual store by nullifying the reference.\n     *\n     * @public\n     * @param   {object}\n     * @return  {void}\n     */\n\n    flushCacheStore(query) {\n        const store = this.getCacheStore(query);\n\n        if (!store) return;\n\n        // TODO: ensure secondary key references are also deleted\n\n        store.$$parent$$.$$store$$ = null;\n    }\n\n    /**\n     * Flushes the entire cache for the resource.\n     *\n     * @public\n     * @return  {void}\n     */\n\n    flushCache() {\n        this.cache = new KeyCache();\n    }\n\n    /**\n     * Configures the resource with a provided user defined\n     * configuration object.\n     *\n     * @private\n     * @param   {object}   config\n     * @param   {function} ConfigModel\n     * @return  {void}\n     */\n\n    configure(config, ConfigModel=ConfigBase) {\n        this.config = new ConfigModel();\n\n        if (!(this.config instanceof ConfigBase)) {\n            throw new TypeError('[resource-base] Resource config must be an ancestor of `ConfigBase`');\n        }\n\n        Util.extend(this.config, config);\n    }\n\n    /**\n     * @param   {*} err\n     * @return  {*}\n     */\n\n    transformError(err) {\n        if (typeof this.config.transformError === 'function') {\n            throw this.config.transformError(err);\n        }\n\n        throw err;\n    }\n\n    /**\n     * Passes a returned response through an optional \"transform\" function,\n     * returning the transformed output before it is written to cache.\n     *\n     * @private\n     * @param   {object[]} response\n     * @return  {object[]}\n     */\n\n    transformResponse(response) {\n        if (typeof this.config.transformResponse === 'function') {\n            return this.config.transformResponse(response);\n        }\n\n        return response;\n    }\n\n    /**\n     * Maps the entry into an optional model after it is retreived from the\n     * cache, then calls an optional `transformEntry` function.\n     *\n     * @private\n     * @param   {object}           entry\n     * @param   {(object|null)}    req\n     * @return  {Promise.<object>}\n     */\n\n    transformEntry(entry, req) {\n        let model = null;\n\n        return Promise.resolve()\n            .then(() => {\n                if (typeof this.config.Model !== 'function') {\n                    model = entry;\n\n                    return;\n                }\n\n                model = new this.config.Model();\n\n                Util.extend(model, entry, true);\n\n                if (typeof model.init === 'function') {\n                    return model.init();\n                }\n            })\n            .then(() => {\n                if (typeof this.config.transformEntry === 'function') {\n                    return this.config.transformEntry(model, req);\n                }\n\n                return model;\n            })\n            .then(model => {\n                if (typeof model === 'undefined') {\n                    throw new Error('[ResourceBase] The provided `transformEntry()` function returned `undefined`');\n                }\n\n                return model;\n            });\n    }\n\n    /**\n     * Queries and returns a reference to an individual store.\n     *\n     * @private\n     * @param   {object} query\n     * @return  {(object[]|null)}\n     */\n\n    readFromCache(query) {\n        const store = this.getCacheStore(query);\n\n        return store;\n    }\n\n    /**\n     * Queries a store and writes one or more entries to it.\n     *\n     * @private\n     * @param   {object}      query\n     * @param   {object[]}    entries\n     * @return  {void}\n     */\n\n    writeToCache(query, entries) {\n        const store                 = this.getCacheStore(query, true);\n        const cacheBySecondaryKeys  = this.config.secondaryKeys.length > 0;\n\n        let primaryKeyValue = null;\n        let cacheByPrimaryKey = false;\n\n        if ((primaryKeyValue = query[this.config.primaryKey]) && Array.isArray(primaryKeyValue)) {\n            cacheByPrimaryKey = true;\n        }\n\n        this.writeEntriesToStore(store, entries, cacheByPrimaryKey, cacheBySecondaryKeys);\n    }\n\n    /**\n     * A generic method for retrieving a cache store via query,\n     * optionally building the store if absent.\n     *\n     * @private\n     * @param   {object}    query\n     * @param   {boolean}   buildCache\n     * @return  {object[]|null}\n     */\n\n    getCacheStore(query, buildCache=false) {\n        let keyCache    = this.cache;\n        let valueCache  = null;\n        let queryKeys   = null;\n        let key         = '';\n        let value       = '';\n        let i           = -1;\n\n        query = query || {};\n\n        queryKeys = Object.keys(query);\n\n        keyCache = this.cache;\n\n        if (queryKeys.length < 1) {\n            if (!keyCache.$$store$$ && buildCache) {\n                keyCache.$$store$$ = ResourceBase.buildFreshStore(keyCache);\n            }\n\n            return keyCache.$$store$$;\n        }\n\n        for (i = 0; i < queryKeys.length; i++) {\n            key = queryKeys[i];\n\n            if (Array.isArray(query[key])) {\n                // Coerce array queries to strings, but mark as array\n                // with quasi-array notation\n\n                value = '(' + query[key].toString() + ')[]';\n            } else {\n                value = query[key];\n            }\n\n            valueCache = keyCache[key];\n\n            if (!valueCache && buildCache) {\n                valueCache = (keyCache[key] = new ValueCache());\n            } else if (!valueCache) {\n                return null;\n            }\n\n            keyCache = valueCache[value];\n\n            if (!keyCache && buildCache) {\n                keyCache = (valueCache[value] = new KeyCache());\n\n                keyCache.$$parent$$ = valueCache;\n                keyCache.$$value$$ = value;\n            } else if (!keyCache) {\n                return null;\n            }\n\n            if (i === queryKeys.length - 1) {\n                if (!keyCache.$$store$$ && buildCache) {\n                    keyCache.$$store$$ = ResourceBase.buildFreshStore(keyCache);\n                }\n\n                return keyCache.$$store$$;\n            }\n        }\n    }\n\n    /**\n     * Writes one or more entries to a store, optionally caching\n     * them by their secondary keys if defined.\n     *\n     * @private\n     * @param   {object[]}    store\n     * @param   {object[]}    entries\n     * @param   {boolean}     cacheByPrimaryKey\n     *     This must be set explicitly to prevent infinite recursion\n     * @param   {boolean}     cacheBySecondaryKeys\n     *     This must be set explicitly to prevent infinite recursion\n     * @return  {void}\n     */\n\n    writeEntriesToStore(store, entries, cacheByPrimaryKey=false, cacheBySecondaryKeys=false) {\n        let entry    = null;\n        let altStore = null;\n        let query    = null;\n        let key      = '';\n        let i        = -1;\n        let j        = -1;\n\n        if (store.length > 0) throw new Error('[resource-base] Store not empty');\n\n        for (i = 0; (entry = entries[i]); i++) {\n            store.push(entry);\n\n            if (cacheByPrimaryKey) {\n                let query = {};\n\n                query[this.config.primaryKey] = entry[this.config.primaryKey];\n\n                this.writeToCache(query, [entry]);\n            }\n\n            if (!cacheBySecondaryKeys) continue;\n\n            for (j = 0; j < this.config.secondaryKeys.length; j++) {\n                key = this.config.secondaryKeys[j];\n\n                if (typeof entry[key] === 'string') {\n                    query = {};\n                    query[key] = entry[key];\n\n                    altStore = this.getCacheStore(query);\n\n                    if (altStore.length < 1) {\n                        this.writeEntriesToStore(altStore, [entry]);\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * Instantiates a decorated array to act as the store, adding a circular\n     * reference to the parent cache for nullification.\n     *\n     * @private\n     * @static\n     * @param   {KeyCache} keyCache\n     * @return  {object[]}\n     */\n\n    static buildFreshStore(keyCache) {\n        const store = [];\n\n        Object.defineProperty(store, '$$parent$$', {\n            get() {\n                return keyCache;\n            }\n        });\n\n        return store;\n    }\n\n    /**\n     * @param   {('get'|'update'|'create'|'delete')}  type\n     * @param   {object}                              data\n     * @return  {string}\n     */\n\n    static getRequestId(type, data) {\n        const json = JSON.stringify(data);\n\n        return type + '_' + json;\n    }\n}\n\nexport default ResourceBase;"]}